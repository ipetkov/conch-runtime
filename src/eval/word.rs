use env::{StringWrapper, VariableEnvironment};
use future::{Async, EnvFuture, Poll};
use new_eval::{Fields, TildeExpansion, WordEval, WordEvalConfig};
use std::borrow::Borrow;
use std::iter::Fuse;
use std::mem;
use std::vec::IntoIter;
use syntax::ast::Word;

impl<T, W, E: ?Sized> WordEval<E> for Word<T, W>
    where T: StringWrapper,
          W: WordEval<E, EvalResult = T>,
          E: VariableEnvironment<Var = T>,
          E::VarName: Borrow<String>,
{
    type EvalResult = T;
    type Error = W::Error;
    type EvalFuture = EvalWord<Self::EvalResult, W, W::EvalFuture>;

    fn eval_with_config(self, env: &mut E, cfg: WordEvalConfig) -> Self::EvalFuture {
        let state = match self {
            Word::Simple(s) => State::Simple(s.eval_with_config(env, cfg)),
            Word::SingleQuoted(s) => State::SingleQuoted(Some(Fields::Single(s))),
            Word::DoubleQuoted(v) => State::DoubleQuoted(DoubleQuoted {
                fields: Vec::new(),
                cur_field: None,
                future: None,
                rest: v.into_iter().fuse(),
            }),
        };

        EvalWord {
            state: state,
        }
    }
}

/// A future representing the evaluation of a `Word`.
#[must_use = "futures do nothing unless polled"]
#[derive(Debug)]
pub struct EvalWord<T, W, F> {
    state: State<T, W, F>,
}

#[derive(Debug)]
enum State<T, W, F> {
    Simple(F),
    SingleQuoted(Option<Fields<T>>),
    DoubleQuoted(DoubleQuoted<T, W, F>),
}

#[derive(Debug)]
struct DoubleQuoted<T, W, F> {
    fields: Vec<T>,
    cur_field: Option<String>,
    future: Option<F>,
    rest: Fuse<IntoIter<W>>,
}

impl<E: ?Sized, T, W> EnvFuture<E> for EvalWord<T, W, W::EvalFuture>
    where T: StringWrapper,
          W: WordEval<E, EvalResult = T>,
          E: VariableEnvironment<Var = T>,
          E::VarName: Borrow<String>,
{
    type Item = Fields<T>;
    type Error = W::Error;

    fn poll(&mut self, env: &mut E) -> Poll<Self::Item, Self::Error> {
        match self.state {
            State::Simple(ref mut s) => s.poll(env),
            State::SingleQuoted(ref mut t) => Ok(Async::Ready(t.take().expect("polled twice"))),
            State::DoubleQuoted(ref mut d) => d.poll(env),
        }
    }

    fn cancel(&mut self, env: &mut E) {
        match self.state {
            State::Simple(ref mut s) => s.cancel(env),
            State::SingleQuoted(_) => {},
            State::DoubleQuoted(ref mut d) => d.cancel(env),
        }
    }
}

impl<T, W, F> DoubleQuoted<T, W, F> {
    fn append_to_cur_field(&mut self, t: T) where T: StringWrapper {
        match self.cur_field {
            Some(ref mut cur) => cur.push_str(t.as_str()),
            None => self.cur_field = Some(t.into_owned()),
        }
    }
}

impl<E: ?Sized, T, W> EnvFuture<E> for DoubleQuoted<T, W, W::EvalFuture>
    where T: StringWrapper,
          W: WordEval<E, EvalResult = T>,
          E: VariableEnvironment<Var = T>,
          E::VarName: Borrow<String>,
{
    type Item = Fields<T>;
    type Error = W::Error;

    fn poll(&mut self, env: &mut E) -> Poll<Self::Item, Self::Error> {
        loop {
            if self.future.is_none() {
                if let Some(w) = self.rest.next() {
                    // Make sure we are NOT doing any tilde expanions for further field splitting
                    let cfg = WordEvalConfig {
                        tilde_expansion: TildeExpansion::None,
                        split_fields_further: false,
                    };

                    self.future = Some(w.eval_with_config(env, cfg));
                }
            }

            let next = match self.future {
                None => {
                    self.cur_field.take().map(|s| self.fields.push(s.into()));
                    let fields = mem::replace(&mut self.fields, Vec::new());
                    return Ok(Async::Ready(fields.into()));
                }

                Some(ref mut f) => try_ready!(f.poll(env)),
            };

            // Ensure we don't poll twice
            self.future = None;

            match next {
                Fields::Zero => continue,
                Fields::Single(s) => self.append_to_cur_field(s),

                // Since we should have indicated we do NOT want field splitting,
                // we should never encounter a Split variant, however, since we
                // cannot control external implementations, we'll fallback
                // somewhat gracefully rather than panicking.
                f@Fields::Split(_) |
                f@Fields::Star(_) => self.append_to_cur_field(f.join_with_ifs(env)),

                // Any fields generated by $@ must be maintained, however, the first and last
                // fields of $@ should be concatenated to whatever comes before/after them.
                Fields::At(v) => {
                    // According to the POSIX spec, if $@ is empty it should generate NO fields
                    // even when within double quotes.
                    if !v.is_empty() {
                        let mut iter = v.into_iter().fuse();
                        iter.next().map(|s| self.append_to_cur_field(s));

                        self.cur_field.take().map(|s| self.fields.push(s.into()));

                        let mut last = None;
                        for next in iter {
                            self.fields.extend(last.take());
                            last = Some(next);
                        }

                        last.map(|s| self.append_to_cur_field(s));
                    }
                },
            }
        }
    }

    fn cancel(&mut self, env: &mut E) {
        self.future.as_mut().map(|f| f.cancel(env));
    }
}
